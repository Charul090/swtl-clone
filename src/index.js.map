{
  "version": 3,
  "sources": ["../render.js", "../router.js", "../main.js", "../index.js"],
  "sourcesContent": ["export function render (html) {\n    const textEncoder = new TextEncoder();\n    const byteHtml = textEncoder.encode(html);\n    const readAbleStream = new ReadableStream({\n        pull: (controller) => {\n            controller.enqueue(byteHtml);\n            controller.close();\n        }\n    });\n    const headers = { \n        'Content-Type': 'text/html'\n    };\n    const response = new Response(readAbleStream, { headers })\n    return response;\n};\n", "import { render } from './render';\n\nexport class Router {\n    /**\n     * \n     * @param {*} routes Array<{ path: string, render: (params, query, request) => string }>\n     */\n    constructor(routes) {\n        this.routes = routes;\n    }\n\n    handleRequest (req) {\n        const url = req.url;\n        let pathInfo;\n        const matchedRoute = this.routes.find(route => {\n            const urlPattern = new URLPattern({ pathname: route.path });\n            const isMatch = urlPattern.test(url);\n            if (isMatch) {\n                pathInfo = urlPattern.exec(url);\n            }\n\n            return isMatch;\n        });\n\n        const params = pathInfo.pathname.groups;\n        const search = {};\n        const searchParams = new URLSearchParams(pathInfo.search.groups[0]);\n        for (const [key, value] of searchParams.entries()) {\n            search[key] = value;\n        }\n\n        const htmlTemplate = matchedRoute.render(params, search, url);\n        return render(htmlTemplate);\n    }\n}", "import { Router } from './router';\n\nexport const router = new Router(\n    [\n        {\n            path: '/',\n            render: () => (`<html><body><h1>Check 1234s</h1></body></html>`)\n        },\n        {\n            path: '/about',\n            render: () => (`<html><body><h1>About</h1></body></html>`)\n        }\n    ]\n);", "import { router } from './main';\n\nself.addEventListener('install', (event) => {\n    event.waitUntil(self.skipWaiting());\n    console.log('service worker installed', event);\n});\n\nself.addEventListener('activate', (event) => {\n    event.waitUntil(\n        self.clients.claim()\n      );\n    console.log('service worker activated', event);\n});\n\nself.addEventListener('fetch', (event) => {\n    if (event.request.mode === 'navigate') {\n        console.log('fetch', event);\n        event.respondWith(router.handleRequest(event.request));\n    }\n});"],
  "mappings": ";;AAAO,WAAS,OAAQ,MAAM;AAC1B,UAAM,cAAc,IAAI,YAAY;AACpC,UAAM,WAAW,YAAY,OAAO,IAAI;AACxC,UAAM,iBAAiB,IAAI,eAAe;AAAA,MACtC,MAAM,CAAC,eAAe;AAClB,mBAAW,QAAQ,QAAQ;AAC3B,mBAAW,MAAM;AAAA,MACrB;AAAA,IACJ,CAAC;AACD,UAAM,UAAU;AAAA,MACZ,gBAAgB;AAAA,IACpB;AACA,UAAM,WAAW,IAAI,SAAS,gBAAgB,EAAE,QAAQ,CAAC;AACzD,WAAO;AAAA,EACX;;;ACZO,MAAM,SAAN,MAAa;AAAA;AAAA;AAAA;AAAA;AAAA,IAKhB,YAAY,QAAQ;AAChB,WAAK,SAAS;AAAA,IAClB;AAAA,IAEA,cAAe,KAAK;AAChB,YAAM,MAAM,IAAI;AAChB,UAAI;AACJ,YAAM,eAAe,KAAK,OAAO,KAAK,WAAS;AAC3C,cAAM,aAAa,IAAI,WAAW,EAAE,UAAU,MAAM,KAAK,CAAC;AAC1D,cAAM,UAAU,WAAW,KAAK,GAAG;AACnC,YAAI,SAAS;AACT,qBAAW,WAAW,KAAK,GAAG;AAAA,QAClC;AAEA,eAAO;AAAA,MACX,CAAC;AAED,YAAM,SAAS,SAAS,SAAS;AACjC,YAAM,SAAS,CAAC;AAChB,YAAM,eAAe,IAAI,gBAAgB,SAAS,OAAO,OAAO,CAAC,CAAC;AAClE,iBAAW,CAAC,KAAK,KAAK,KAAK,aAAa,QAAQ,GAAG;AAC/C,eAAO,GAAG,IAAI;AAAA,MAClB;AAEA,YAAM,eAAe,aAAa,OAAO,QAAQ,QAAQ,GAAG;AAC5D,aAAO,OAAO,YAAY;AAAA,IAC9B;AAAA,EACJ;;;AChCO,MAAM,SAAS,IAAI;AAAA,IACtB;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,QAAQ,MAAO;AAAA,MACnB;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,QAAQ,MAAO;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ;;;ACXA,OAAK,iBAAiB,WAAW,CAAC,UAAU;AACxC,UAAM,UAAU,KAAK,YAAY,CAAC;AAClC,YAAQ,IAAI,4BAA4B,KAAK;AAAA,EACjD,CAAC;AAED,OAAK,iBAAiB,YAAY,CAAC,UAAU;AACzC,UAAM;AAAA,MACF,KAAK,QAAQ,MAAM;AAAA,IACrB;AACF,YAAQ,IAAI,4BAA4B,KAAK;AAAA,EACjD,CAAC;AAED,OAAK,iBAAiB,SAAS,CAAC,UAAU;AACtC,QAAI,MAAM,QAAQ,SAAS,YAAY;AACnC,cAAQ,IAAI,SAAS,KAAK;AAC1B,YAAM,YAAY,OAAO,cAAc,MAAM,OAAO,CAAC;AAAA,IACzD;AAAA,EACJ,CAAC;",
  "names": []
}
